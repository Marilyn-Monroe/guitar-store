//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for FindAllGuitarsParamsOrder.
const (
	FindAllGuitarsParamsOrderAsc  FindAllGuitarsParamsOrder = "asc"
	FindAllGuitarsParamsOrderDesc FindAllGuitarsParamsOrder = "desc"
)

// Defines values for FindReviewsByGuitarIdParamsOrder.
const (
	FindReviewsByGuitarIdParamsOrderAsc  FindReviewsByGuitarIdParamsOrder = "asc"
	FindReviewsByGuitarIdParamsOrderDesc FindReviewsByGuitarIdParamsOrder = "desc"
)

// GetCartItemsByUserIdParams defines parameters for GetCartItemsByUserId.
type GetCartItemsByUserIdParams struct {
	// UserId ID of the user whose cart items are to be retrieved
	UserId openapi_types.UUID `form:"userId" json:"userId"`
}

// EditCartItemJSONBody defines parameters for EditCartItem.
type EditCartItemJSONBody struct {
	GuitarId *openapi_types.UUID `json:"guitar_id,omitempty"`
	Quantity *int64              `json:"quantity,omitempty"`
	UserId   *openapi_types.UUID `json:"user_id,omitempty"`
}

// FindAllGuitarsParams defines parameters for FindAllGuitars.
type FindAllGuitarsParams struct {
	// Type Filter guitars by type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Strings Filter guitars by the number of strings
	Strings *int `form:"strings,omitempty" json:"strings,omitempty"`

	// MinPrice Filter guitars with a price greater than or equal to this value
	MinPrice *float32 `form:"min_price,omitempty" json:"min_price,omitempty"`

	// MaxPrice Filter guitars with a price less than or equal to this value
	MaxPrice *float32 `form:"max_price,omitempty" json:"max_price,omitempty"`

	// Sort Sort guitars by a specific field
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order: ascending (asc) or descending (desc)
	Order *FindAllGuitarsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit The number of items to return per page
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page The page number to return
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`
}

// FindAllGuitarsParamsOrder defines parameters for FindAllGuitars.
type FindAllGuitarsParamsOrder string

// GetPromocodeByCodeParams defines parameters for GetPromocodeByCode.
type GetPromocodeByCodeParams struct {
	// Code The promocode code to retrieve information for
	Code string `form:"code" json:"code"`
}

// FindReviewsByGuitarIdParams defines parameters for FindReviewsByGuitarId.
type FindReviewsByGuitarIdParams struct {
	// GuitarId ID of the guitar
	GuitarId openapi_types.UUID `form:"guitarId" json:"guitarId"`

	// Sort Sort guitars by a specific field
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order: ascending (asc) or descending (desc)
	Order *FindReviewsByGuitarIdParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit The number of items to return per page
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Page The page number to return
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`
}

// FindReviewsByGuitarIdParamsOrder defines parameters for FindReviewsByGuitarId.
type FindReviewsByGuitarIdParamsOrder string

// CreateReviewJSONBody defines parameters for CreateReview.
type CreateReviewJSONBody struct {
	Advantages    *string            `json:"advantages,omitempty"`
	Comments      *string            `json:"comments,omitempty"`
	Disadvantages *string            `json:"disadvantages,omitempty"`
	GuitarId      openapi_types.UUID `json:"guitar_id"`
	Rating        int64              `json:"rating"`
}

// EditCartItemJSONRequestBody defines body for EditCartItem for application/json ContentType.
type EditCartItemJSONRequestBody EditCartItemJSONBody

// CreateReviewJSONRequestBody defines body for CreateReview for application/json ContentType.
type CreateReviewJSONRequestBody CreateReviewJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get cart items for a user
	// (GET /cartItem)
	GetCartItemsByUserId(w http.ResponseWriter, r *http.Request, params GetCartItemsByUserIdParams)
	// Edit a cart item
	// (PATCH /cartItem)
	EditCartItem(w http.ResponseWriter, r *http.Request)
	// Find all guitars
	// (GET /guitar)
	FindAllGuitars(w http.ResponseWriter, r *http.Request, params FindAllGuitarsParams)
	// Get a single guitar
	// (GET /guitar/{guitarId})
	GetGuitarById(w http.ResponseWriter, r *http.Request, guitarId openapi_types.UUID)
	// Get promocode information by code
	// (GET /promocode/findByCode)
	GetPromocodeByCode(w http.ResponseWriter, r *http.Request, params GetPromocodeByCodeParams)
	// Find reviews by guitarId
	// (GET /review)
	FindReviewsByGuitarId(w http.ResponseWriter, r *http.Request, params FindReviewsByGuitarIdParams)
	// Create a new review
	// (POST /review)
	CreateReview(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetCartItemsByUserId operation middleware
func (siw *ServerInterfaceWrapper) GetCartItemsByUserId(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCartItemsByUserIdParams

	// ------------- Required query parameter "userId" -------------

	if paramValue := r.URL.Query().Get("userId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "userId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "userId", r.URL.Query(), &params.UserId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "userId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCartItemsByUserId(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EditCartItem operation middleware
func (siw *ServerInterfaceWrapper) EditCartItem(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EditCartItem(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// FindAllGuitars operation middleware
func (siw *ServerInterfaceWrapper) FindAllGuitars(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindAllGuitarsParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	// ------------- Optional query parameter "strings" -------------

	err = runtime.BindQueryParameter("form", true, false, "strings", r.URL.Query(), &params.Strings)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "strings", Err: err})
		return
	}

	// ------------- Optional query parameter "min_price" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_price", r.URL.Query(), &params.MinPrice)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "min_price", Err: err})
		return
	}

	// ------------- Optional query parameter "max_price" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_price", r.URL.Query(), &params.MaxPrice)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "max_price", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindAllGuitars(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetGuitarById operation middleware
func (siw *ServerInterfaceWrapper) GetGuitarById(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "guitarId" -------------
	var guitarId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "guitarId", r.PathValue("guitarId"), &guitarId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "guitarId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetGuitarById(w, r, guitarId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetPromocodeByCode operation middleware
func (siw *ServerInterfaceWrapper) GetPromocodeByCode(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPromocodeByCodeParams

	// ------------- Required query parameter "code" -------------

	if paramValue := r.URL.Query().Get("code"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "code"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code", r.URL.Query(), &params.Code)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "code", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPromocodeByCode(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// FindReviewsByGuitarId operation middleware
func (siw *ServerInterfaceWrapper) FindReviewsByGuitarId(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params FindReviewsByGuitarIdParams

	// ------------- Required query parameter "guitarId" -------------

	if paramValue := r.URL.Query().Get("guitarId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "guitarId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "guitarId", r.URL.Query(), &params.GuitarId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "guitarId", Err: err})
		return
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", r.URL.Query(), &params.Sort)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort", Err: err})
		return
	}

	// ------------- Optional query parameter "order" -------------

	err = runtime.BindQueryParameter("form", true, false, "order", r.URL.Query(), &params.Order)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "order", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.FindReviewsByGuitarId(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateReview operation middleware
func (siw *ServerInterfaceWrapper) CreateReview(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateReview(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/cartItem", wrapper.GetCartItemsByUserId)
	m.HandleFunc("PATCH "+options.BaseURL+"/cartItem", wrapper.EditCartItem)
	m.HandleFunc("GET "+options.BaseURL+"/guitar", wrapper.FindAllGuitars)
	m.HandleFunc("GET "+options.BaseURL+"/guitar/{guitarId}", wrapper.GetGuitarById)
	m.HandleFunc("GET "+options.BaseURL+"/promocode/findByCode", wrapper.GetPromocodeByCode)
	m.HandleFunc("GET "+options.BaseURL+"/review", wrapper.FindReviewsByGuitarId)
	m.HandleFunc("POST "+options.BaseURL+"/review", wrapper.CreateReview)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xb/W4buRF/FYLtHz1AseTYKRD9F7uXg4G7qxHHxQFBIIyWIy3vdskNyZWsGgL6Gn29",
	"PklBcr8/5PXmQzlA/yTSLjlfnBn+ZkZ+pIGMEylQGE3njzREYKjcx/LFInu6+O0W1lyA4VJcy1QYu4yh",
	"DhRP7DM6p++lgYiINF6iInJFuMFY0wnVQYgx2PUrqWIwdE65MH+/pBNqdgn6r7hGRff7yROsf+Yx72D9",
	"a8FUoUmVQPZVuN/CGtvMr1OlUBiSwBoz9Z/Jdz+hCSiI0bTtX75YRN3Kvw+xaXViZGYJkqByktEJ5Xb1",
	"pxTVjk6ogNgK4WkeFDfmgsdpTOfnT5msIqtUDFVb1jupDBdr4l7PCegABbMP/gY6+IFIRez6/Jn9/EOP",
	"4J5BVXAUVsgPFHRAJ44v/VhIrI3iYn1A4KTzbK1tK+da2rVHqszSX9qaWirTbUyyTrkBpclyR4DoBAO+",
	"4gFZcYxYj4yOWFXGpon2E6rwU4raXEnGsemRtXeLa4Vg8B1uOG79QmHQpwdIkogHLnKmv2sr8mOF618V",
	"ruic/mVakp76t7ryaJE9WmQcnHR1M/g39mgCJwv14nOFjM6NSrFu1rr4PzJurkGZG4Px1xS/4NGhwH3C",
	"wCAjASjj4pcwNMAj3dbEHY1OpNAdx5I9X1zOZlfA3nk9v6ZS/4KIM0frR6Wk6tLNBlBmcbIFTbjY2E02",
	"0gMQQhqyRCJNiGrLNRKNaoPsjDaPrFTt/F5AakKp+L+tVb6ecr+g1jaaO5R6k5oQhclYWbdj9itEmmxR",
	"IYm51j7LES4CqRQG5pBOF2+lWnLGUBxJoeopcU1SYW8+IyWbkGVqfZKEoMkSURCFq1SjO0AIAtTabrDn",
	"CFEkt4fP7vJXad7KVLAjqnn/7iZX1aKEmkcaZwYtUxVgZRGT6FXEB66NPqTh62spVhEPzLE8U+xI7F+T",
	"bciDkOhQphEjIUaJ0y/V+TWmZbRB9yzIhD6g2cvX76X8BcQuSyv6O/DUMoH4tEFYilY1q1JFnv/957+a",
	"KDBIHNghIWxscDpvxocQUnfIq8b599vi1Wx2IwwqAdGd5at88juOPe5kjCa0+nBNlkr+geKQ5BdWYh7g",
	"vYAN8AiWER7xIN2xKZdxEp9p5AZVJIEhI1tuwvyo9Rl5r3YE1sAFicCg6lfyLnVpKWd9pGPxQjhIly1v",
	"XNctYDB/pImSCSqTQS6P7Bac1XBkmnJGW7B2Qj+lIAw3u8Ogc9YGnRNqU8IwNvviiVz+joFpHEJTJ6cG",
	"zz+MRkwFU1AKdj08iyCsGzGQDJsmuXhJu8zgMXMbD09oXPrSOIM44T7LGhnAGmSKn5zjtG0BG1SwxoUC",
	"W4PVrLKKJJjSKlkVa8k7SM0WYGrrLWB9YXiMXa5YC4UOcw70aB5nNi9XKt610Nc1HYwSxQMcVIKX8bOo",
	"JcYBG/UfaSdz/0kPpOKfjPUvf+Kf5WCZ0wzzsEpyrbvYZ0fKrZKxzIO2O5Sf7W+M60CmwiwgzjtXA04E",
	"HxKuUC+4GLghhodFqps+27++x20HGqqsuBtBzjYgDKz9t5YtAhnHecOvy1BPbH/endSRaIobCR78jfTq",
	"yZZIWQJ/yClWBSlz1HJXafgMMN5nxUvejxgUL81CuXVqWFwQY+4F/dxLyj7iYiXbPaU3RPM4iZC8ub1x",
	"mNgbmmgjlUv23NjMSH26IHfZ4w0q7Qmcn83OZlYemaCAhNM5vTibnV3QCU3AhE7HaVABPWt0EWmt4Sx0",
	"wyx5LLoy+mp3r1HdMFrvkn5oin7zDyJXZY2zDaXGsqeiCShXHSwtxjeK4wb7OmRpzq/efens6/UApY+N",
	"Rs3L2exbtJd0Fxj9mWtjTVOxRV7tZA1DZM5mdFIdAvz2oux8vyh6/l2CZZumQ8YG+0mdcNHRH0/Yk2gS",
	"zpv14+neFuD+0p9eF6nilKcDenGO1PloUvXelyN2MZpYpenkKF2OplS2dRyh16MJld0TS+jlaELtZsV+",
	"Ql+NPsOegt/RvBhNs6sUd+ViGsegdj4JNmMW8jg1YKHlB1pk0o9uiGSCsJ1Maz3uam9/1y98pUc+HdY8",
	"33dnvBG2aVTwp/g7xd9R4s+6N4EyBLvDbj+h03VRcXeimbdcsDdRlFdpT+CYtzwyqKqDPQcuuqFK9qp/",
	"mDcZQL42QM7r1p7hYfG2xbKC2Z/g6Vp7QFx5TtYOvVs4AoJIRfBTCpFv43JNNhClfbrHXCx8id+JzHp6",
	"Gs+TLkKtx4gGDyNF6/Ll0l2mB+bDo3f7Ufro7VEGv0ZudyPzb42X81A8gJbXRbSeMPEJE5/u5O/jTrZX",
	"KYEoqoRnfidnl3D1Rp4++v9v2P5Qq8Fng6vdc3oMGbcs/SdgwjL750z/TB2EvP/bTohZqyf/Tcop9E+h",
	"f7RyGIjmYh1Vwq8z+pN8ijBdccGudtfZ6KAvARRTh2zpE1nA/Sow30LcP/6Hga6rSLjwsc2lsEV7D0QM",
	"PKP+BHHkhFBOYjpyQvHylBZOaeH4aaEMxmrsLXckC7I8SRTrsjyhiiFab92ejYqudj+Vl/ooiNAI/y+C",
	"EU714jdKhvnA8EC96H2pa7RS+MGpkDwVkqdr4zsqJPOYXe5IJR/nt0V2O7jJitQd90Ptbx++5GClRrg9",
	"WDk/DVZOsfcnjj3v3gSIwG0Wg11h5zY5uTzOSlVE53QKCZ9uLhwEyLY0Idg/8yjVRGHk/rbGyErHqAbB",
	"aHsg0L2/AI8VEiWgHEolSzklCZVH+bD95UC4UkoWM9iP+/8HAAD//2Nx0rLWOQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
